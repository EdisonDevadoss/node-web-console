{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Default configs.\n */\nconst DEFAULT_DELIMITER = \"/\";\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to consider delimiters when parsing. (default: `undefined`, any character)\n   */\n  whitelist?: string | string[];\n}\n\n/**\n * Normalize a pathname for matching, replaces multiple slashes with a single\n * slash and normalizes unicode characters to \"NFC\". When using this method,\n * `decode` should be an identity function so you don't decode strings twice.\n */\nexport function normalizePathname(pathname: string) {\n  return decodeURI(pathname).replace(/\\/+/g, \"/\");\n}\n\n/**\n * Balanced bracket helper function.\n */\nfunction balanced(open: string, close: string, str: string, index: number) {\n  let count = 0;\n  let i = index;\n\n  while (i < str.length) {\n    if (str[i] === \"\\\\\") {\n      i += 2;\n      continue;\n    }\n\n    if (str[i] === close) {\n      count--;\n\n      if (count === 0) return i + 1;\n    }\n\n    if (str[i] === open) {\n      count++;\n    }\n\n    i++;\n  }\n\n  return -1;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = [];\n  const defaultDelimiter = options.delimiter ?? DEFAULT_DELIMITER;\n  const whitelist = options.whitelist ?? undefined;\n  let i = 0;\n  let key = 0;\n  let path = \"\";\n  let isEscaped = false;\n\n  // tslint:disable-next-line\n  while (i < str.length) {\n    let prefix = \"\";\n    let name = \"\";\n    let pattern = \"\";\n\n    // Ignore escaped sequences.\n    if (str[i] === \"\\\\\") {\n      i++;\n      path += str[i++];\n      isEscaped = true;\n      continue;\n    }\n\n    if (str[i] === \":\") {\n      while (++i < str.length) {\n        const code = str.charCodeAt(i);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[i];\n          continue;\n        }\n\n        break;\n      }\n\n      // False positive on param name.\n      if (!name) i--;\n    }\n\n    if (str[i] === \"(\") {\n      const end = balanced(\"(\", \")\", str, i);\n\n      // False positive on matching brackets.\n      if (end > -1) {\n        pattern = str.slice(i + 1, end - 1);\n        i = end;\n\n        if (pattern[0] === \"?\") {\n          throw new TypeError(\"Path pattern must be a capturing group\");\n        }\n\n        if (/\\((?=[^?])/.test(pattern)) {\n          const validPattern = pattern.replace(/\\((?=[^?])/, \"(?:\");\n\n          throw new TypeError(\n            `Capturing groups are not allowed in pattern, use a non-capturing group: (${validPattern})`\n          );\n        }\n      }\n    }\n\n    // Add regular characters to the path string.\n    if (name === \"\" && pattern === \"\") {\n      path += str[i++];\n      isEscaped = false;\n      continue;\n    }\n\n    // Extract the final character from `path` for the prefix.\n    if (path.length && !isEscaped) {\n      const char = path[path.length - 1];\n      const matches = whitelist ? whitelist.indexOf(char) > -1 : true;\n\n      if (matches) {\n        prefix = char;\n        path = path.slice(0, -1);\n      }\n    }\n\n    // Push the current path onto the list of tokens.\n    if (path.length) {\n      tokens.push(path);\n      path = \"\";\n    }\n\n    const repeat = str[i] === \"+\" || str[i] === \"*\";\n    const optional = str[i] === \"?\" || str[i] === \"*\";\n    const delimiter = prefix || defaultDelimiter;\n\n    // Increment `i` past modifier token.\n    if (repeat || optional) i++;\n\n    tokens.push({\n      name: name || key++,\n      prefix,\n      delimiter,\n      optional,\n      repeat,\n      pattern:\n        pattern ||\n        `[^${escapeString(\n          delimiter === defaultDelimiter\n            ? delimiter\n            : delimiter + defaultDelimiter\n        )}]+?`\n    });\n  }\n\n  if (path.length) tokens.push(path);\n\n  return tokens;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = encodeURIComponent, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map(token => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment;\n        continue;\n      }\n\n      if (token.optional) continue;\n\n      const typeOfMessage = token.repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & RegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function(pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.repeat) {\n        params[key.name] = m[i].split(key.delimiter).map(value => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  delimiter: string;\n  optional: boolean;\n  repeat: boolean;\n  pattern: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  // Use a negative lookahead to match only capturing groups.\n  const groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (let i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: \"\",\n        delimiter: \"\",\n        optional: false,\n        repeat: false,\n        pattern: \"\"\n      });\n    }\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: RegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map(path => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: RegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: RegexpOptions = {}\n) {\n  const {\n    strict,\n    start = true,\n    end = true,\n    delimiter = DEFAULT_DELIMITER\n  } = options;\n  const endsWith = (typeof options.endsWith === \"string\"\n    ? options.endsWith.split(\"\")\n    : options.endsWith || []\n  )\n    .map(escapeString)\n    .concat(\"$\")\n    .join(\"|\");\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(token);\n    } else {\n      const capture = token.repeat\n        ? `(?:${token.pattern})(?:${escapeString(token.delimiter)}(?:${\n            token.pattern\n          }))*`\n        : token.pattern;\n\n      if (keys) keys.push(token);\n\n      if (token.optional) {\n        if (!token.prefix) {\n          route += `(${capture})?`;\n        } else {\n          route += `(?:${escapeString(token.prefix)}(${capture}))?`;\n        }\n      } else {\n        route += `${escapeString(token.prefix)}(${capture})`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `(?:${escapeString(delimiter)})?`;\n\n    route += endsWith === \"$\" ? \"$\" : `(?=${endsWith})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? endToken[endToken.length - 1] === delimiter\n        : // tslint:disable-next-line\n          endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${escapeString(delimiter)}(?=${endsWith}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${escapeString(delimiter)}|${endsWith})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\nexport interface RegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp allows an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string | string[];\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: RegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys);\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(path, keys, options);\n  }\n\n  return stringToRegexp(path, keys, options);\n}\n"]}